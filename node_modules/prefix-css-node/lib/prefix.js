// Generated by CoffeeScript 1.4.0
(function() {
  var any, combToText, css, options, parserlib, prefix,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  parserlib = require("parserlib");

  any = function(xs, f) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  };

  options = {
    starHack: true,
    ieFilters: true,
    underscoreHack: true,
    strict: false
  };

  combToText = function(combinator) {
    if (combinator.text === ' ') {
      return combinator.text;
    } else {
      return " " + combinator + " ";
    }
  };

  prefix = function(pref, blacklist) {
    return function(selector) {
      var elementName, hangoverCombinator, idx, modifiers, ms, output, part, re, text, watchForFollowingElems, _i, _len, _ref, _ref1, _ref2, _ref3;
      output = [];
      watchForFollowingElems = false;
      hangoverCombinator = null;
      _ref = selector.parts;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        part = _ref[idx];
        if ((part.elementName != null) && watchForFollowingElems && (_ref1 = part.elementName.text, __indexOf.call(blacklist, _ref1) >= 0)) {
          hangoverCombinator = null;
        } else if (watchForFollowingElems && part instanceof parserlib.css.Combinator) {
          if ((_ref2 = part.type) === 'descendant' || _ref2 === 'child') {
            hangoverCombinator = part;
          } else {
            output.push(part.text);
            watchForFollowingElems = false;
          }
        } else if (idx > 0) {
          if (hangoverCombinator != null) {
            output.push(combToText(hangoverCombinator));
            hangoverCombinator = null;
          }
          text = part instanceof parserlib.css.Combinator ? combToText(part) : part.text;
          output.push(text);
          watchForFollowingElems = false;
        } else {
          elementName = part.elementName, modifiers = part.modifiers;
          ms = modifiers;
          if (_ref3 = elementName != null ? elementName.text : void 0, __indexOf.call(blacklist, _ref3) >= 0) {
            re = new RegExp(elementName.text, 'g');
            output.push(part.text.replace(re, pref));
            watchForFollowingElems = true;
          } else if ((elementName === null) && ms.length && (any(ms, function(m) {
            var _ref4;
            return _ref4 = m.text, __indexOf.call(blacklist, _ref4) >= 0;
          }))) {
            output.push(part.text);
          } else {
            output.push("" + pref + " " + part);
          }
        }
      }
      return output.join('');
    };
  };

  exports.css = css = function(input, text, blacklist) {
    var closeBrace, lastLine, nlIfNeeded, output, parser, process, ruleLine;
    if (blacklist == null) {
      blacklist = ['html', 'body'];
    }
    output = [];
    parser = new parserlib.css.Parser(options);
    process = prefix(text, blacklist);
    ruleLine = 0;
    lastLine = 1;
    nlIfNeeded = function(event) {
      var current, newLine;
      current = event.line;
      newLine = current > lastLine;
      if (newLine) {
        output.push('\n');
      }
      lastLine = current;
      return newLine;
    };
    closeBrace = function(event) {
      nlIfNeeded(event);
      return output.push("}");
    };
    parser.addListener('charset', function(event) {
      lastLine = event.line;
      return output.push("@charset " + event.charset + ";");
    });
    parser.addListener('namespace', function(event) {
      nlIfNeeded(event);
      return output.push("@namespace " + event.prefix + " " + event.uri + ";");
    });
    parser.addListener('import', function(event) {
      nlIfNeeded(event);
      return output.push("@import " + event.uri + " " + (event.media.join(',')) + ";");
    });
    parser.addListener('startfontface', function() {
      nlIfNeeded(event);
      return output.push("@fontface {");
    });
    parser.addListener('startpage', function(event) {
      var _ref;
      nlIfNeeded(event);
      return output.push("@page " + ((_ref = event.pseudo) != null ? _ref : '') + " {");
    });
    parser.addListener('startpagemargin', function(event) {
      nlIfNeeded(event);
      return output.push("@" + event.margin + " {");
    });
    parser.addListener('startmedia', function(event) {
      nlIfNeeded(event);
      return output.push("@media " + (event.media.join(',')) + " {");
    });
    parser.addListener('startkeyframes', function(event) {
      var vendorPref;
      nlIfNeeded(event);
      vendorPref = event.prefix ? "-" + event.prefix + "-" : '';
      return output.push("@" + vendorPref + "keyframes " + event.name + " {");
    });
    parser.addListener('startkeyframerule', function(event) {
      var indent, offset, onNewLine;
      onNewLine = nlIfNeeded(event);
      offset = event.col;
      indent = onNewLine ? new Array(offset).join(' ') : ' ';
      return output.push("" + indent + (event.keys.join(' ')) + " {");
    });
    parser.addListener('startrule', function(event) {
      var delim, prefixed, selectors, startLine;
      nlIfNeeded(event);
      selectors = event.selectors.slice();
      prefixed = selectors.map(process);
      startLine = selectors[0].line;
      lastLine = ruleLine = selectors[selectors.length - 1].line;
      delim = startLine === ruleLine ? ' ' : '\n';
      output.push(prefixed.join(',' + delim));
      return output.push(' {');
    });
    parser.addListener('endmedia', closeBrace);
    parser.addListener('endkeyframes', closeBrace);
    parser.addListener('endpagemargin', closeBrace);
    parser.addListener('endpage', closeBrace);
    parser.addListener('endfontface', closeBrace);
    parser.addListener('endrule', closeBrace);
    parser.addListener('endkeyframerule', closeBrace);
    parser.addListener('property', function(event) {
      var delim, importance, important, indent, offset, onNewLine, property, value;
      onNewLine = nlIfNeeded(event);
      property = event.property, value = event.value, important = event.important;
      offset = property.col;
      indent = onNewLine ? new Array(offset).join(' ') : '';
      importance = important ? '!important' : '';
      delim = offset + property.text.length + 1 === value.col ? '' : ' ';
      return output.push("" + indent + event.property + ":" + delim + event.value + importance + ";");
    });
    parser.parse(input);
    return output.join('');
  };

  exports.prefixer = function(text, blacklist) {
    return function(input) {
      return css(input, text, blacklist);
    };
  };

}).call(this);
